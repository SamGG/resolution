% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/cluster_resolution.R
\name{cluster_resolution}
\alias{cluster_resolution}
\title{cluster_resolution}
\usage{
cluster_resolution(graph, t = 1, directed = FALSE, RandomOrder = FALSE,
  rep = 1)
}
\arguments{
\item{graph}{An igraph network or a data frame of three columns: source, target, and weights.}

\item{t}{The time-scale parameter of the process which uncovers community structures at different resolutions.}

\item{directed}{Logical. TRUE if the network is directed. Ignored if graph is an igraph object.}

\item{RandomOrder}{If is NULL we receive the outcome based on order of vertices in graph, If is FALSE vertices will be arrange in alphabetical order, othervise vertices will be arrange in random order.}

\item{rep}{If you choose random order of verticles (RandomOrder=TRUE) you can set the number of repetitions and then will be returned the best solution (which will be
have the highest value of modularity) among these repetitions. In the other cases this parameter is ommited.}
}
\value{
If we use igraph input function returns a communities object (as algorithms implemented in igraph package). Please look the example (*) or see the \url{http://igraph.org/r/doc/communities.html} to find out what you can do.
        If we use data.frame input we receive single column table with informations about community which has been found for each node. The rownames are names of nodes.
}
\description{
cluster_resolution function has been created based on paper "Laplacian dynamics and Multiscale Modular Structure in Networks" R. Lambiotte et al.
               Algorithm finds communities using stability as an objective function to be optimised
                 in order to find the best partition  of network. The number of communities
                 typically decreases as time grows, from a partition of one-node communities which are as many as nodes when t = 0 to a
                 two-way partition as t -> inf.
}
\examples{
library(igraph)
g <- nexus.get("miserables")
cluster_resolution(g,directed=FALSE,t=1,RandomOrder=NULL)
cluster_resolution(g,directed=FALSE,t=1,RandomOrder=FALSE)
cluster_resolution(g,directed=FALSE,t=1,RandomOrder=TRUE)
cluster_resolution(g,directed=FALSE,t=1,RandomOrder=TRUE,rep=10)
# example (*):
c <- cluster_resolution(g,directed=FALSE,t=1,RandomOrder=TRUE,rep=3)
c$membership  # A numeric vector, one value for each vertex, the id of its community.
c$memberships # It returns all the obtained results in matrix where columns corespond to the vertices and rows to the repetitions.
c$modularity  # Vector of modularity for each reperitions.
c$names       # Names of nodes.
c$vcount      # How many communities have been founded.
c$algorithm   # The name of the algorithm that was used to calculate the community structure
print(c)      # Prints a short summary.
membership(c) # The (best) membership vector, which had the highest value of modularity.
modularity(c) # The highest modularity value.
length(c)     # The number of communities.
sizes(c)      # Returns the community sizes, in the order of their ids.
algorithm(c)  # The name of the algorithm that was used to calculate the community structure.
crossing(c,g) # Returns a logical vector, with one value for each edge, ordered according to the edge ids. The value is TRUE iff the edge connects two different communities, according to the (best) membership vector, as returned by membership().
}

